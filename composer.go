package binary

import (
	"bufio"
	"bytes"
	"compress/gzip"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strconv"
)

// Delims
const (
	ldelim = "{{"
	rdelim = "}}"
)

const utiltmpl = `
// Bytes to retrieve file data
func Bytes(filename string) (b []byte, e error) {
	var r bytes.Buffer
	defer r.Truncate(0)
	part, ok := data[filename]
	if !ok {
		return nil, errors.New("file does not exist")
	}
	ch := make(chan []byte, 1)
	go func() {
		cont := strings.Join(part, "")
		data := []byte(cont)
		gz, err := gzip.NewReader(bytes.NewBuffer(data))
		if err != nil {
			e = err
			ch <- nil
			return
		}
		var buf bytes.Buffer
		if _, err = io.Copy(&buf, gz); err != nil {
			e = err
			ch <- nil
			return
		}
		if err := gz.Close(); err != nil {
			e = err
			ch <- nil
			return
		}
		ch <- buf.Bytes()
	}()
	return <-ch, nil
}

// MustBytes to read bytes data from file
func MustBytes(filename string) []byte {
	b, err := Bytes(filename)
	if err != nil {
		log.Panic(err)
	}
	return b
}
`

const readtmpl = `//
// code generated by binary-go.
//
// DO NOT EDIT!

package {{ .Package }}

import (
	"bytes"
	"compress/gzip"
	"errors"
	"log"
	"io"
	"strings"
)

var data = map[string][]string{
	{{ range .Files -}}"{{ .Filepath }}": []string{
		{{ range .Hashes -}}
		d{{ . }},
		{{- end }}
	},
	{{ end }}
}
`

// File template
const filetmpl = `//
// code generated by binary-go.
// source: {{ .Filepath }}
//
// DO NOT EDIT!

package {{ .Package }}

var d{{ .Hash }} = "{{ .Data }}"

`

// Reader struct
type Reader struct {
	Package string
	Files   []*File
}

// File struct
type File struct {
	Filepath string
	Size     int64
	Hashes   []string
}

// Source struct
type Source struct {
	Package, Filepath, Hash, Data string
}

// Template struct
type Template struct {
	blk, src *template.Template
}

// Composer struct
type Composer struct {
	dir, out, pkg string
	max           int
	tree          *Tree
	tmpl          *Template
}

// NewComposer to create composer instance
func NewComposer(dir, out, pkg string, max int) *Composer {
	tmpl := new(Template)
	switch b, err := template.New("blk").Delims(ldelim, rdelim).Parse(filetmpl); {
	case err != nil:
		log.Fatal(err)
	default:
		tmpl.blk = b
	}
	switch b, err := template.New("src").Delims(ldelim, rdelim).Parse(readtmpl); {
	case err != nil:
		log.Fatal(err)
	default:
		tmpl.src = b
	}
	return &Composer{
		dir:  dir,
		out:  out,
		pkg:  pkg,
		max:  max,
		tmpl: tmpl,
	}
}

// Scan files and directories
func (v *Composer) Scan() error {
	abs, err := filepath.Abs(v.dir)
	if err != nil {
		return err
	}
	f, err := os.Open(abs)
	if err != nil {
		return err
	}
	defer f.Close()
	tree := new(Tree)
	tree.name = filepath.Dir(abs)
	tree.path = abs
	tree.dirs = make([]*Tree, 0)
	tree.assets = make([]*Asset, 0)
	v.deep(tree, abs)
	v.tree = tree
	return nil
}

// Iter assets
func (v *Composer) Iter() <-chan *Asset {
	return v.tree.Iter()
}

// path builds path string
func (v *Composer) path(args ...string) string {
	var w bytes.Buffer
	for _, s := range args {
		w.WriteString(s)
	}
	return w.String()
}

// deep scan
func (v *Composer) deep(root *Tree, path string) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()
	s, err := f.Stat()
	if err != nil {
		return err
	}
	switch mode := s.Mode(); {
	case mode.IsDir():
		di, err := f.Readdir(-1)
		if err != nil {
			return err
		}
		for _, fi := range di {
			abs := v.path(root.Pwd(), string(os.PathSeparator), fi.Name())
			switch mode := fi.Mode(); {
			case mode.IsRegular():
				root.assets = append(
					root.assets,
					NewAsset(abs, fi.Name()),
				)
			case mode.IsDir():
				tree := new(Tree)
				tree.name = filepath.Dir(abs)
				tree.path = abs
				tree.dirs = make([]*Tree, 0)
				tree.assets = make([]*Asset, 0)
				tree.parent = root
				root.dirs = append(
					root.dirs,
					tree,
				)
				v.deep(tree, abs)
			}
		}
	case mode.IsRegular():
		root.assets = append(
			root.assets,
			NewAsset(root.Pwd(), filepath.Base(f.Name())),
		)
	}
	return nil
}

// write content to file
func (v *Composer) write(b []byte, filepath ...string) error {
	fe, err := os.OpenFile(
		v.path(filepath...),
		os.O_TRUNC|os.O_CREATE|os.O_RDWR,
		os.ModeAppend|os.FileMode(0666),
	)
	if err != nil {
		return err
	}
	defer fe.Close()
	fe.Write(b)
	return nil
}

// save part
func (v *Composer) part(fname, fpath string, part int, b []byte) (string, error) {
	var tbuf bytes.Buffer
	defer tbuf.Truncate(0)
	sha1 := sha1.Sum(b)
	hash := hex.EncodeToString(sha1[:])
	if err := v.tmpl.blk.Execute(&tbuf, &Source{
		Package:  v.pkg,
		Filepath: fpath,
		Hash:     hash,
		Data:     string(b[:]),
	}); err != nil {
		return hash, err
	}
	return hash, v.write(tbuf.Bytes(), v.out, string(os.PathSeparator), fname, "-", strconv.Itoa(part), ".go")
}

// process file
func (v *Composer) process(fname, fpath string, data []byte) ([]string, error) {
	var bbuf bytes.Buffer
	var hashes []string
	var n int
	for i, b := range data {
		if i > 0 && bbuf.Len() > v.max {
			hash, err := v.part(fname, fpath, n+1, bbuf.Bytes())
			if err != nil {
				return nil, err
			}
			hashes = append(hashes, hash)
			fmt.Printf("│    %2.2d │ %11d KB │ %40.40v │ %-24.24v │\n", n+1, bbuf.Len(), hash, v.path(fname, "-", strconv.Itoa(n+1), ".go"))
			bbuf.Truncate(0)
			n++
		}
		fmt.Fprintf(&bbuf, "\\x%02x", b)
	}
	hash, err := v.part(fname, fpath, n+1, bbuf.Bytes())
	if err != nil {
		return nil, err
	}
	hashes = append(hashes, hash)
	fmt.Printf("│    %2.2d │ %11d KB │ %40.40v │ %-24.24v │\n", n+1, bbuf.Len(), hash, v.path(fname, "-", strconv.Itoa(n+1), ".go"))
	bbuf.Truncate(0)
	return hashes, nil
}

// Compile template
func (v *Composer) Compile(ch chan error) {
	go func() {
		ch <- v.Compose()
	}()
}

// Compose template
func (v *Composer) Compose() error {
	var files []*File
	fmt.Printf("┌───────┬────────────────┬──────────────────────────────────────────┬──────────────────────────┐\n")
	fmt.Printf("│ %5v │ %14v │ %-40.40v │ %-24.24v │\n", "PART", "SIZE", "HASH", "FILE")
	fmt.Printf("├───────┼────────────────┼──────────────────────────────────────────┼──────────────────────────┤\n")
	for asset := range v.tree.Iter() {
		var zbuf bytes.Buffer
		defer zbuf.Truncate(0)
		zw := gzip.NewWriter(&zbuf)
		fw := bufio.NewWriter(zw)
		for b := range asset.Pipe() {
			fw.Write(b)
		}
		if err := fw.Flush(); err != nil {
			return err
		}
		if err := zw.Close(); err != nil {
			return err
		}
		hashes, err := v.process(asset.Filename(), asset.Relpath(), zbuf.Bytes())
		if err != nil {
			return err
		}
		file := &File{
			Filepath: asset.Relpath(),
			Size:     asset.Size(),
			Hashes:   hashes,
		}
		files = append(files, file)
	}
	fmt.Printf("└───────┴────────────────┴──────────────────────────────────────────┴──────────────────────────┘\n")
	var w bytes.Buffer
	defer w.Truncate(0)
	if err := v.tmpl.src.Execute(&w, &Reader{
		Package: v.pkg,
		Files:   files,
	}); err != nil {
		return err
	}
	w.WriteString(utiltmpl)
	if err := v.write(
		w.Bytes(),
		v.path(v.out, string(os.PathSeparator), "binary.go"),
	); err != nil {
		return err
	}
	return nil
}
