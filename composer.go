package binary

import (
	"bytes"
	"compress/gzip"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"html/template"
	"log"
	"math"
	"os"
	"path/filepath"
	"strconv"
)

// Delims
const (
	ldelim = "{{"
	rdelim = "}}"
)

const readtmpl = `//
// code generated by binary-go.
//
// DO NOT EDIT!

package {{ .Package }}

var data = map[string][]string{
	{{ range .Files -}}"{{ .Filepath }}": []string{
		{{ range .Hashes -}}
		d{{ . }},
		{{- end }}
	},
	{{ end }}
}

var size = map[string]int{
	{{ range .Files -}}
	"{{ .Filepath }}": {{ .Size }},
	{{ end }}
}

`

// File template
const filetmpl = `//
// code generated by binary-go.
// source: %s
//
// DO NOT EDIT!

package %s

var d%s = "%s"

`

// Reader struct
type Reader struct {
	Package string
	Files   []*File
}

// File struct
type File struct {
	Filepath string
	Size     int64
	Hashes   []string
}

// Template struct
type Template struct {
	blk *template.Template
	src *template.Template
}

// Composer struct
type Composer struct {
	dir, out, pkg string
	max           int
	tree          *Tree
	tmpl          *Template
}

// NewComposer to create composer instance
func NewComposer(dir, out, pkg string, max int) *Composer {
	tmpl := new(Template)
	switch b, err := template.New("blk").Delims(ldelim, rdelim).Parse(DataTmpl); {
	case err != nil:
		log.Fatal(err)
	default:
		tmpl.blk = b
	}
	switch b, err := template.New("src").Delims(ldelim, rdelim).Parse(readtmpl); {
	case err != nil:
		log.Fatal(err)
	default:
		tmpl.src = b
	}
	fmt.Println("max", max)
	return &Composer{
		dir:  dir,
		out:  out,
		pkg:  pkg,
		max:  max,
		tmpl: tmpl,
	}
}

// Scan files and directories
func (v *Composer) Scan() error {
	abs, err := filepath.Abs(v.dir)
	if err != nil {
		return err
	}
	f, err := os.Open(abs)
	if err != nil {
		return err
	}
	defer f.Close()
	tree := new(Tree)
	tree.name = filepath.Dir(abs)
	tree.path = abs
	tree.dirs = make([]*Tree, 0)
	tree.assets = make([]*Asset, 0)
	v.deep(tree, abs)
	v.tree = tree
	return nil
}

// Iter assets
func (v *Composer) Iter() <-chan *Asset {
	return v.tree.Iter()
}

// path builds path string
func (v *Composer) path(args ...string) string {
	var w bytes.Buffer
	for _, s := range args {
		w.WriteString(s)
	}
	return w.String()
}

// deep scan
func (v *Composer) deep(root *Tree, path string) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()
	s, err := f.Stat()
	if err != nil {
		return err
	}
	switch mode := s.Mode(); {
	case mode.IsDir():
		di, err := f.Readdir(-1)
		if err != nil {
			return err
		}
		for _, fi := range di {
			abs := v.path(root.Pwd(), string(os.PathSeparator), fi.Name())
			switch mode := fi.Mode(); {
			case mode.IsRegular():
				root.assets = append(
					root.assets,
					NewAsset(abs, fi.Name()),
				)
			case mode.IsDir():
				tree := new(Tree)
				tree.name = filepath.Dir(abs)
				tree.path = abs
				tree.dirs = make([]*Tree, 0)
				tree.assets = make([]*Asset, 0)
				tree.parent = root
				root.dirs = append(
					root.dirs,
					tree,
				)
				v.deep(tree, abs)
			}
		}
	case mode.IsRegular():
		root.assets = append(
			root.assets,
			NewAsset(root.Pwd(), filepath.Base(f.Name())),
		)
	}
	return nil
}

// write content to file
func (v *Composer) write() error {
	return nil
}

// Compose template
func (v *Composer) Compose() error {
	var files []*File
	for asset := range v.tree.Iter() {
		var zbuf bytes.Buffer
		defer zbuf.Truncate(0)
		zw := gzip.NewWriter(&zbuf)
		for b := range asset.Pipe() {
			zw.Write(b)
		}
		if err := zw.Close(); err != nil {
			return err
		}
		si := zbuf.Len()
		var bbuf bytes.Buffer
		defer bbuf.Truncate(0)
		for i, b := range zbuf.Bytes() {
			bbuf.WriteString(strconv.Itoa(int(b)))
			if i < si-1 {
				bbuf.WriteRune(' ')
			}
		}
		part := uint64(math.Ceil(float64(bbuf.Len()) / float64(v.max)))
		file := &File{
			Filepath: asset.Relpath(),
			Size:     asset.Size(),
			Hashes:   make([]string, part),
		}
		for i := uint64(0); i < part; i++ {
			size := bbuf.Len()
			if size > v.max {
				size = v.max
			}
			pbuf := make([]byte, size)
			bbuf.Read(pbuf)
			sha1 := sha1.Sum(pbuf)
			hash := hex.EncodeToString(sha1[:])
			fe, err := os.OpenFile(
				v.path(v.out, string(os.PathSeparator), asset.Filename(), "-", strconv.FormatUint(i+1, 10), ".go"),
				os.O_TRUNC|os.O_CREATE|os.O_RDWR,
				os.ModeAppend|os.FileMode(0666),
			)
			if err != nil {
				return err
			}
			defer fe.Close()
			fmt.Fprintf(fe, filetmpl,
				asset.Relpath(),
				v.pkg,
				hash,
				pbuf,
			)
			file.Hashes[i] = hash
		}
		files = append(files, file)
	}
	var w bytes.Buffer
	defer w.Truncate(0)
	if err := v.tmpl.src.Execute(&w, &Reader{
		Package: v.pkg,
		Files:   files,
	}); err != nil {
		return err
	}
	fe, err := os.OpenFile(
		v.path(v.out, string(os.PathSeparator), "binary.go"),
		os.O_TRUNC|os.O_CREATE|os.O_RDWR,
		os.ModeAppend|os.FileMode(0666),
	)
	if err != nil {
		return err
	}
	defer fe.Close()
	fe.Write(w.Bytes())
	return nil
}
