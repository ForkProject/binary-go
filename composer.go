package binary

import (
	"bytes"
	"compress/gzip"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"html/template"
	"log"
	"math"
	"os"
	"path/filepath"
	"strconv"
)

// Delims
const (
	ldelim = "{{"
	rdelim = "}}"
)

const readtmpl = `//
// code generated by binary-go.
//
// DO NOT EDIT!

package {{ .Package }}

import (
	"bytes"
	"compress/gzip"
	"errors"
	"log"
	"strconv"
	"strings"
)

var data = map[string][]string{
	{{ range .Files -}}"{{ .Filepath }}": []string{
		{{ range .Hashes -}}
		d{{ . }},
		{{- end }}
	},
	{{ end }}
}

var size = map[string]int{
	{{ range .Files -}}
	"{{ .Filepath }}": {{ .Size }},
	{{ end }}
}

// Bytes to retrieve file data
func Bytes(filename string) ([]byte, error) {
	var r bytes.Buffer
	defer r.Truncate(0)
	part, ok := data[filename]
	if !ok {
		return nil, errors.New("file does not exist")
	}
	size, ok := size[filename]
	if !ok {
		return nil, errors.New("could not find file size information")
	}
	cont := strings.Join(part, "")
	arry := strings.Split(cont, " ")
	for _, v := range arry {
		n, err := strconv.Atoi(v)
		if err != nil {
			return nil, err
		}
		b := byte(n)
		r.WriteByte(b)
	}
	data := make([]byte, size)
	bytr := bytes.NewReader(r.Bytes())
	gz, err := gzip.NewReader(bytr)
	if err != nil {
		return nil, err
	}
	defer gz.Close()
	if _, err := gz.Read(data); err != nil {
		return nil, err
	}
	return data, nil
}

// MustBytes to read bytes data from file
func MustBytes(filename string) []byte {
	b, err := Bytes(filename)
	if err != nil {
		log.Panic(err)
	}
	return b
}

`

// File template
const filetmpl = `//
// code generated by binary-go.
// source: {{ .Filepath }}
//
// DO NOT EDIT!

package {{ .Package }}

var d{{ .Hash }} = "{{ .Data }}"

`

// Reader struct
type Reader struct {
	Package string
	Files   []*File
}

// File struct
type File struct {
	Filepath string
	Size     int64
	Hashes   []string
}

// Source struct
type Source struct {
	Package, Filepath, Hash, Data string
}

// Template struct
type Template struct {
	blk, src *template.Template
}

// Composer struct
type Composer struct {
	dir, out, pkg string
	max           int
	tree          *Tree
	tmpl          *Template
}

// NewComposer to create composer instance
func NewComposer(dir, out, pkg string, max int) *Composer {
	tmpl := new(Template)
	switch b, err := template.New("blk").Delims(ldelim, rdelim).Parse(filetmpl); {
	case err != nil:
		log.Fatal(err)
	default:
		tmpl.blk = b
	}
	switch b, err := template.New("src").Delims(ldelim, rdelim).Parse(readtmpl); {
	case err != nil:
		log.Fatal(err)
	default:
		tmpl.src = b
	}
	return &Composer{
		dir:  dir,
		out:  out,
		pkg:  pkg,
		max:  max,
		tmpl: tmpl,
	}
}

// Scan files and directories
func (v *Composer) Scan() error {
	abs, err := filepath.Abs(v.dir)
	if err != nil {
		return err
	}
	f, err := os.Open(abs)
	if err != nil {
		return err
	}
	defer f.Close()
	tree := new(Tree)
	tree.name = filepath.Dir(abs)
	tree.path = abs
	tree.dirs = make([]*Tree, 0)
	tree.assets = make([]*Asset, 0)
	v.deep(tree, abs)
	v.tree = tree
	return nil
}

// Iter assets
func (v *Composer) Iter() <-chan *Asset {
	return v.tree.Iter()
}

// path builds path string
func (v *Composer) path(args ...string) string {
	var w bytes.Buffer
	for _, s := range args {
		w.WriteString(s)
	}
	return w.String()
}

// deep scan
func (v *Composer) deep(root *Tree, path string) error {
	f, err := os.Open(path)
	if err != nil {
		return err
	}
	defer f.Close()
	s, err := f.Stat()
	if err != nil {
		return err
	}
	switch mode := s.Mode(); {
	case mode.IsDir():
		di, err := f.Readdir(-1)
		if err != nil {
			return err
		}
		for _, fi := range di {
			abs := v.path(root.Pwd(), string(os.PathSeparator), fi.Name())
			switch mode := fi.Mode(); {
			case mode.IsRegular():
				root.assets = append(
					root.assets,
					NewAsset(abs, fi.Name()),
				)
			case mode.IsDir():
				tree := new(Tree)
				tree.name = filepath.Dir(abs)
				tree.path = abs
				tree.dirs = make([]*Tree, 0)
				tree.assets = make([]*Asset, 0)
				tree.parent = root
				root.dirs = append(
					root.dirs,
					tree,
				)
				v.deep(tree, abs)
			}
		}
	case mode.IsRegular():
		root.assets = append(
			root.assets,
			NewAsset(root.Pwd(), filepath.Base(f.Name())),
		)
	}
	return nil
}

// write content to file
func (v *Composer) write(filepath string, b []byte) error {
	fe, err := os.OpenFile(
		filepath,
		os.O_TRUNC|os.O_CREATE|os.O_RDWR,
		os.ModeAppend|os.FileMode(0666),
	)
	if err != nil {
		return err
	}
	defer fe.Close()
	fe.Write(b)
	return nil
}

// Compose template
func (v *Composer) Compose() error {
	var files []*File
	fmt.Printf("┌────────────┬────────────────┬──────────────────────────────────────────┬──────────────────────────┐\n")
	fmt.Printf("│ %10v │ %14v │ %-40.40v │ %-24.24v │\n", "PART", "SIZE", "HASH", "FILE")
	fmt.Printf("├────────────┼────────────────┼──────────────────────────────────────────┼──────────────────────────┤\n")
	for asset := range v.tree.Iter() {
		var zbuf bytes.Buffer
		defer zbuf.Truncate(0)
		zw := gzip.NewWriter(&zbuf)
		for b := range asset.Pipe() {
			zw.Write(b)
		}
		if err := zw.Close(); err != nil {
			return err
		}
		si := zbuf.Len()
		var bbuf bytes.Buffer
		defer bbuf.Truncate(0)
		for i, b := range zbuf.Bytes() {
			bbuf.WriteString(strconv.Itoa(int(b)))
			if i < si-1 {
				bbuf.WriteRune(' ')
			}
		}
		part := uint64(math.Ceil(float64(bbuf.Len()) / float64(v.max)))
		file := &File{
			Filepath: asset.Relpath(),
			Size:     asset.Size(),
			Hashes:   make([]string, part),
		}
		for i := uint64(0); i < part; i++ {
			var tbuf bytes.Buffer
			size := bbuf.Len()
			if size > v.max {
				size = v.max
			}
			pbuf := make([]byte, size)
			bbuf.Read(pbuf)
			sha1 := sha1.Sum(pbuf)
			hash := hex.EncodeToString(sha1[:])
			if err := v.tmpl.blk.Execute(&tbuf, &Source{
				Package:  v.pkg,
				Filepath: asset.Relpath(),
				Hash:     hash,
				Data:     string(pbuf[:]),
			}); err != nil {
				return err
			}
			v.write(
				v.path(v.out, string(os.PathSeparator), asset.Filename(), "-", strconv.FormatUint(i+1, 10), ".go"),
				tbuf.Bytes(),
			)
			fmt.Printf("│    %2.2d / %2.2d │ %11d KB │ %40.40v │ %-24.24v │\n", i+1, part, size, hash, v.path(asset.Filename(), "-", strconv.FormatUint(i+1, 10), ".go"))
			file.Hashes[i] = hash
			tbuf.Truncate(0)
		}
		files = append(files, file)
	}
	fmt.Printf("└────────────┴────────────────┴──────────────────────────────────────────┴──────────────────────────┘\n")
	var w bytes.Buffer
	defer w.Truncate(0)
	if err := v.tmpl.src.Execute(&w, &Reader{
		Package: v.pkg,
		Files:   files,
	}); err != nil {
		return err
	}
	if err := v.write(
		v.path(v.out, string(os.PathSeparator), "binary.go"),
		w.Bytes(),
	); err != nil {
		return err
	}
	return nil
}
